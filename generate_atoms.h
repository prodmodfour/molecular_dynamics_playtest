#include <thread>
#include <cstdio>
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>
#include <cmath>

#include "Type_atom.h"

#define EV_TO_J_PER_MOLE 96400.0
#define J_PER_MOLE_TO_EV 1.037e-5
#define SCALING 0.01
double atom_spacing = 3.61;

double cu_mass = 63.546;

typedef struct 
{
    int x, y, z;
} block_dimensions;

void print_atoms(std::vector<Type_atom> atoms);
void generate_atom_row(std::vector<Type_atom>& atom_block, Type_atom first_atom, block_dimensions cubes_in,  std::string atom_type);
void generate_atom_xy_plane(std::vector<Type_atom>& atom_block, block_dimensions cubes_in,  std::string atom_type);
void generate_atom_xyz_space(std::vector<Type_atom>& atom_block, Type_atom first_atom, block_dimensions cubes_in,  std::string atom_type);
std::vector<Type_atom> generate_atom_block(block_dimensions cubes_in);

void add_impact_atom(std::vector<Type_atom>& atom_block, double z_offset, double applied_energy, block_dimensions cubes_in);

void print_atoms(std::vector<Type_atom> atoms)
{
    // Print all atoms
    for (int i = 0; i < atoms.size(); i++)
    {
        printf("Index %d x %f y %f z %f\n", i, atoms[i].x, atoms[i].y, atoms[i].z);
    }
}

std::vector<Type_atom> generate_atom_block(block_dimensions cubes_in)
{
    std::vector<Type_atom> atom_block;

    Type_atom first_corner_atom;
    first_corner_atom.x = 0;
    first_corner_atom.y = 0;
    first_corner_atom.z = 0;
    generate_atom_xyz_space(atom_block, first_corner_atom, cubes_in, "corner");


    Type_atom first_centre_atom;
    first_centre_atom.x = atom_spacing / 2;
    first_centre_atom.y = atom_spacing / 2;
    first_centre_atom.z = atom_spacing / 2;
    generate_atom_xyz_space(atom_block, first_centre_atom, cubes_in, "centre");

    return atom_block;
}

void generate_atom_row(std::vector<Type_atom>& atom_block, Type_atom first_atom, block_dimensions cubes_in, std::string atom_type)
{
    int number_repeats;
    if(atom_type == "corner")
    {
        number_repeats = cubes_in.x + 1;
    }
    else if (atom_type == "centre")
    {
        number_repeats = cubes_in.x;
    }
    else
    {
        std::cout << "Incorrect atom type (" << atom_type << ") given for atom row" << std::endl;
        return;
    }

    Type_atom atom;
    atom.y = first_atom.y;
    atom.z = first_atom.z;
    for (int i = 0; i < number_repeats; i++)
    {
        atom.x = first_atom.x + (i * atom_spacing);
        atom_block.push_back(atom);
    }
}

void generate_atom_xy_plane(std::vector<Type_atom>& atom_block, Type_atom first_atom, block_dimensions cubes_in, std::string atom_type)
{
    int number_repeats;
    if(atom_type == "corner")
    {
        number_repeats = cubes_in.y + 1;
    }
    else if (atom_type == "centre")
    {
        number_repeats = cubes_in.y;
    }
    else
    {
        std::cout << "Incorrect atom type (" << atom_type << ") given for atom plane" << std::endl;
        return;
    }

    Type_atom atom;
    atom.x = first_atom.x;
    atom.z = first_atom.z;
    for (int i = 0; i < number_repeats; i++)
    {
        atom.y = first_atom.y + (i * atom_spacing);
        generate_atom_row(atom_block, atom, cubes_in, atom_type);
    }
}

void generate_atom_xyz_space(std::vector<Type_atom>& atom_block, Type_atom first_atom, block_dimensions cubes_in, std::string atom_type)
{
    int number_repeats;
    if(atom_type == "corner")
    {
        number_repeats = cubes_in.z + 1;
    }
    else if (atom_type == "centre")
    {
        number_repeats = cubes_in.z;
    }
    else
    {
        std::cout << "Incorrect atom type (" << atom_type << ") given for atom block" << std::endl;
        return;
    }

    Type_atom atom;
    atom.x = first_atom.x;
    atom.y = first_atom.y;
    
    for (int i = 0; i < number_repeats; i++)
    {
        atom.z = first_atom.z + (i * atom_spacing);
        generate_atom_xy_plane(atom_block, atom, cubes_in, atom_type);
    }
}

void add_impact_atom(std::vector<Type_atom>& atom_block, double z_offset, double applied_energy, block_dimensions cubes_in)
{
    // Adds an impact atom z-offset above the centre of the top xy_surface of the block
    // This function assumes that the input atom block was generated by the other functions in this file. 
    Type_atom impact_atom;

    double highest_x = cubes_in.x * atom_spacing;
    double x = (highest_x) / 2;
    impact_atom.x = x;

    double highest_y = cubes_in.y * atom_spacing;
    double y = (highest_y) / 2;
    impact_atom.y = y;

    double highest_z = cubes_in.z * atom_spacing;
    impact_atom.z = highest_z + z_offset;

    impact_atom.fx = 0;
    impact_atom.fy = 0;
    impact_atom.fz = 0;

    impact_atom.vx = 0;
    impact_atom.vy = 0;
    applied_energy *= EV_TO_J_PER_MOLE;
    impact_atom.vz = -std::sqrt((2.0*applied_energy)/cu_mass);

    atom_block.push_back(impact_atom);
}